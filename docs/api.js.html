<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: api.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: api.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { basename, join } from 'path-browserify';
import { parser, lexer } from 'marked';

/**
 * @typedef Item
 * @property {string} sha
 * @property {'blob'|'tree'} type
 * @property {string} path
 */

/**
 * @typedef {Item} ItemRaw
 * @property {string} url
 * @property {string} mode
 * @property {number} size
 */

import { isDotFile, isFile } from './utils';

const MAX_FILE_SIZE = 5000;

const RUNNING_REQUESTS = {
  allData: undefined,
  definition: undefined,
  people: undefined,
  places: undefined,
  organizations: undefined,
  topics: undefined,
  mdToHtml: undefined,
};

const CACHE = {
  definitions: {},
  postText: {},
  people: {},
  places: {},
  organizations: {},
  topics: {},
  sentiment: {},
};

/**
 * @returns {Promise&lt;{blobs: Array&lt;Item>, trees: Array&lt;Item>}|null>}
 */
const getBlogData = async () => {
  if (RUNNING_REQUESTS.allData !== undefined) {
    RUNNING_REQUESTS.allData.abort();
  }
  let result = null;
  const controller = new AbortController();
  try {
    const res = await fetch(`${process.env.REACT_APP_API_ROOT}/trees/master?recursive=1`, {
      mode: 'cors',
      signal: controller.signal,
      headers: {
        Accept: 'application/json, *',
        Authorization: process.env.REACT_APP_AUTHORIZATION,
      }
    });
    if (!res.ok) {
      throw new Error(JSON.stringify(res.body));
    }
    let { tree } = await res.json();
    tree = tree.filter((n) => !isDotFile(n.path)).map((n) => ({ ...n, path: `/${n.path}` })).sort((a, b) => basename(a.path).localeCompare(basename(b.path)));
    result = {
      trees: Object.fromEntries(
        tree
          .filter((n) => n.type === 'tree' &amp;&amp; basename(n.path).indexOf('.') &lt; 0)
          .map(({ url, mode, ...rest }) => rest)
          .map(({ path, ...rest }) => [path, rest])
      ),
      blobs: Object.fromEntries(
        tree
          .filter((n) => n.type === 'blob' &amp;&amp; isFile(n.path) &amp;&amp; n.size &lt;= MAX_FILE_SIZE)
          .map(({ url, mode, size, ...rest }) => rest)
          .map(({ path, ...rest }) => [path, rest])
      ),
    };
  } catch (e) {
    console.error(e);
  } finally {
    delete RUNNING_REQUESTS.allData;
  }
  return result;
};

const mdToHtmlLocally = (md) => parser(lexer(md));

/**
 * @param {Array&lt;*>} xs
 * @returns {Array&lt;*>}
 */
const unique = (xs) => [...new Set(xs)];

/**
 * @param {string} post
 * @param {string} category
 * @param {string} postText
 * @param {'places'|'organizations'|'topics'|'people'} type
 * @returns {Promise&lt;*>}
 */
const callCompromiseApi = async (post, category, postText, type) => {
  if (RUNNING_REQUESTS[type] !== undefined) {
    RUNNING_REQUESTS[type].abort();
    delete RUNNING_REQUESTS[type];
  }
  const postPath = join(category, post);
  const maybeCached = CACHE[type][postPath];
  let result = null;
  if (maybeCached === undefined) {
    const controller = new AbortController();
    RUNNING_REQUESTS[type] = controller;
    try {
      const res = await fetch(
        `${process.env.REACT_APP_NLP_API_ROOT}/${type}`,
        {
          method: 'post',
          mode: 'cors',
          signal: controller.signal,
          body: postText,
          headers: {
            'Authorization': process.env.REACT_APP_NLP_AUTHORIZATION,
            'Accept': 'application/json, *',
            'Content-Type': 'application/json',
          },
        }
      );
      if (!res.ok) {
        throw new Error(JSON.stringify(res.body));
      }
      const json = await res.json();
      const regex = /^[\d &amp;,.a-z]{2,}$/i;
      result = unique(json.filter((w) => w.search(regex) >= 0));
      CACHE[type][postPath] = result;
    } catch (e) {
      CACHE[type][postPath] = null;
      console.error(e);
    } finally {
      delete RUNNING_REQUESTS[type];
    }
  } else if (maybeCached) {
    result = maybeCached;
  }
  return result;
};

/**
 * @param {string} post
 * @param {string} category
 * @param {string} postText
 * @param {'distance'|'match'|'sentiment'|'stem'|'tokenize'|'tokenizeAndStem'} action
 */
const callNaturalApi = async (post, category, postText, action) => {
  if (RUNNING_REQUESTS[action] !== undefined) {
    RUNNING_REQUESTS[action].abort();
    delete RUNNING_REQUESTS[action];
  }
  let result = null;
  const postPath = join(category, post);
  const maybeCached = CACHE[action][postPath];
  if (maybeCached === undefined) {
    const controller = new AbortController();
    RUNNING_REQUESTS[action] = controller;
    try {
      const res = await fetch(`${process.env.REACT_APP_NLP_API_ROOT}/natural`, {
        mode: 'cors',
        signal: controller.signal,
        body: JSON.stringify({ text: postText, action }),
        method: 'post',
        headers: {
          'Authorization': process.env.REACT_APP_NLP_AUTHORIZATION,
          'Accept': 'application/json, *',
          'Content-Type': 'application/json',
        }
      });
      if (!res.ok) {
        throw new Error(JSON.stringify(res.body));
      }
      result = await res.json();
      CACHE[action][postPath] = result;
    } catch (e) {
      console.error(e);
      CACHE[action][postPath] = null;
    } finally {
      delete RUNNING_REQUESTS[action];
    }
  } else if (maybeCached) {
    result = maybeCached;
  }
  return result;
};

/**
 * @param {string} word
 * @returns {Promise&lt;string>}
 */
const define = async (word) => {
  const maybeCached = CACHE.definitions[word];
  let result = null;
  if (maybeCached === undefined) {
    const controller = new AbortController();
    RUNNING_REQUESTS.definition = controller;
    try {
      const res = await fetch(`${process.env.REACT_APP_NLP_API_ROOT}/define/${word}`, {
        mode: 'cors',
        signal: controller.signal,
        headers: {
          Authorization: process.env.REACT_APP_NLP_AUTHORIZATION,
          Accept: 'text/plain, *',
        }
      });
      if (!res.ok) {
        throw new Error(JSON.stringify(res.body));
      }
      result = await res.text();
      CACHE.definitions[word] = result;
    } catch (e) {
      console.error(e.message);
      CACHE.definitions[word] = null;
    } finally {
      delete RUNNING_REQUESTS.definition;
    }
  } else if (maybeCached) {
    result = maybeCached;
  }
  return result;
};

/**
 * @param {string} sha
 * @returns {Promise&lt;string>}
 */
const getPostHTML = async (sha) => {
  let result = null;
  const maybeCached = CACHE.postText[sha];
  if (maybeCached === undefined) {
    const controller = new AbortController();
    RUNNING_REQUESTS.postText = controller;
    try {
      const res = await fetch(
        `${process.env.REACT_APP_API_ROOT}/blobs/${sha}`, {
          mode: 'cors',
          signal: controller.signal,
          headers: {
            Authorization: process.env.REACT_APP_AUTHORIZATION,
            Accept: 'application/json, *',
          },
        }
      );
      if (!res.ok) {
        throw new Error(JSON.stringify(res.body));
      }
      const json = await res.json();
      const markdown = json.encoding === 'base64'
        ? atob(json.content)
        : json.content;
      result = mdToHtmlLocally(markdown);
      CACHE.postText[sha] = result;
    } catch (e) {
      console.error(e);
    } finally {
      delete RUNNING_REQUESTS.postText;
    }
  } else if (maybeCached) {
    result = maybeCached;
  }
  return result;
};

export {
  getBlogData,
  callCompromiseApi,
  callNaturalApi,
  define,
  mdToHtmlLocally,
  getPostHTML,
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#absCategory">absCategory</a></li><li><a href="global.html#absPost">absPost</a></li><li><a href="global.html#beginLoading">beginLoading</a></li><li><a href="global.html#callCompromiseApi">callCompromiseApi</a></li><li><a href="global.html#callNaturalApi">callNaturalApi</a></li><li><a href="global.html#categories">categories</a></li><li><a href="global.html#checkValidServiceWorker">checkValidServiceWorker</a></li><li><a href="global.html#countSent">countSent</a></li><li><a href="global.html#countWords">countWords</a></li><li><a href="global.html#define">define</a></li><li><a href="global.html#didLoad">didLoad</a></li><li><a href="global.html#endLoading">endLoading</a></li><li><a href="global.html#findAllMatches">findAllMatches</a></li><li><a href="global.html#fmtHeading">fmtHeading</a></li><li><a href="global.html#getBlogData">getBlogData</a></li><li><a href="global.html#getPostBody">getPostBody</a></li><li><a href="global.html#getPostHTML">getPostHTML</a></li><li><a href="global.html#getTimeToReadInMin">getTimeToReadInMin</a></li><li><a href="global.html#initPostText">initPostText</a></li><li><a href="global.html#isDotFile">isDotFile</a></li><li><a href="global.html#isFile">isFile</a></li><li><a href="global.html#isObjectEmpty">isObjectEmpty</a></li><li><a href="global.html#makeClickable">makeClickable</a></li><li><a href="global.html#parentCategories">parentCategories</a></li><li><a href="global.html#parentCategory">parentCategory</a></li><li><a href="global.html#parentPosts">parentPosts</a></li><li><a href="global.html#posts">posts</a></li><li><a href="global.html#register">register</a></li><li><a href="global.html#registerDefinitionsOnWordClick">registerDefinitionsOnWordClick</a></li><li><a href="global.html#registerValidSW">registerValidSW</a></li><li><a href="global.html#render">render</a></li><li><a href="global.html#unique">unique</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Wed Jan 01 2020 11:03:52 GMT+0000 (Greenwich Mean Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
