<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: app.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: app.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import React, { Component } from 'react';

import { Spinner } from 'reactstrap';
import { basename, dirname, join } from 'path-browserify';

import bannedWords from './bannedWords';
import {
  callCompromiseApi,
  callNaturalApi,
  define,
  getBlogData,
  getPostHTML,
} from './api';
import { findAllMatches, isFile, isObjectEmpty } from './utils';

import Footer from './footer';
import WordDefinition from './wordDefinition';
import NLPInfo from './NLPInfo';
import Title from './title';
import TitleMiddle from './titleMiddle';
import ParentCategories from './parentCategories';
import Categories from './categories';
import ParentPosts from './parentPosts';
import Posts from './posts';

export default class App extends Component {
  constructor(props) {
    super(props);
    this.bannedWords = new Set(bannedWords);
    this.author = 'Norbert Logiewa';
    this.naturalApiRequests = ['sentiment'];
    this.compromiseApiRequests = [
      'places', 'organizations', 'topics', 'people',
    ];
    this.state = {
      data: {
        trees: {},
        blobs: {},
      },
      category: '/',
      word: null,
      definition: null,
      post: null,
      postText: '',
      _loading: [],
      ...Object.fromEntries(this.naturalApiRequests.map((e) => [e, null])),
      ...Object.fromEntries(this.compromiseApiRequests.map((e) => [e, []])),
    };
    this.clearDefinition = this.clearDefinition.bind(this);
    this.absCategory = this.absCategory.bind(this);
    this.absPost = this.absPost.bind(this);
  }

  /**
   * @returns {Promise&lt;void>}
   */
  async componentDidMount() {
    this.beginLoading('data');
    try {
      this.setState({
        data: await getBlogData(),
      });
      const path = window.location.pathname;
      if (isFile(path)) {
        this.absPost(path);
      } else {
        this.absCategory(path);
      }
    } catch (e) {
      console.error(e);
    }
    this.endLoading('data');
    window.onpopstate = async ({ state: { category, post } }) => {
      if (post) {
        await this.absPost(post, false);
      }
      if (category) {
        await this.absCategory(category, false);
      }
    };
  }

  /**
   * @returns {string}
   */
  get parentCategory() {
    const { category } = this.state;
    return category === '/' ? '/' : dirname(category);
  }

  /**
   * @returns {string[]}
   */
  get parentPosts() {
    const { state: { category, data: { blobs } }, parentCategory } = this;
    if (category === '/') {
      return [];
    }
    const cat = parentCategory;
    return Object
      .keys(blobs)
      .filter((path) => dirname(path) === cat)
      .map((path) => basename(path));
  }

  /**
   * @returns {string[]}
   */
  get parentCategories() {
    const { state: { category, data: { trees } } } = this;
    if (category === '/') {
      return [];
    }
    const cat = this.parentCategory;
    return Object
      .keys(trees)
      .filter((path) => dirname(path) === cat)
      .map((path) => basename(path));
  }

  /**
   * @returns {string[]}
   */
  get posts() {
    const { state: { category, data: { blobs } } } = this;
    return Object
      .keys(blobs)
      .filter((path) => dirname(path) === category)
      .map((path) => basename(path));
  }

  /**
   * @returns {string[]}
   */
  get categories() {
    const { state: { category, data: { trees } } } = this;
    return Object
      .keys(trees)
      .filter((path) => dirname(path) === category)
      .map((path) => basename(path));
  }

  /**
   * @param {string} newPost
   * @param {boolean} [saveHistory]
   * @returns {Promise&lt;void>}
   */
  async absPost(newPost, saveHistory = true) {
    const { state: { category, post, data: { blobs } } } = this;
    if (category === dirname(newPost) &amp;&amp; post === basename(newPost)) {
      return;
    }
    this.beginLoading('postText');
    if (saveHistory) {
      window.history.pushState({ post: newPost, category }, `Blog - post "${basename(newPost)}"`, newPost);
    }
    this.setState({
      category: dirname(newPost),
      post: basename(newPost),
      postText: '',
    });
    try {
      const postText = await getPostHTML(blobs[newPost].sha);
      this.setState({ postText });
      this.endLoading('postText');
      if (this.state.postText) {
        await this.initPostText(App.getPostBody());
      }
    } catch (e) {
      console.error(e);
    }
  }

  /**
   * @param {string} postBody
   * @returns {Promise&lt;void>}
   */
  async initPostText(postBody) {
    for (const type of this.naturalApiRequests.concat(this.compromiseApiRequests)) {
      this.beginLoading(type);
    }
    for (const type of this.compromiseApiRequests) {
      this.setState({ [type]: [] });
    }
    for (const type of this.naturalApiRequests) {
      this.setState({ [type]: null });
    }
    const p = Promise.all([
      ...this.naturalApiRequests.map(async (type) => {
        const { post: p2, category } = this.state;
        const newState = await callNaturalApi(p2, category, postBody, type);
        if (newState) {
          this.setState({
            // eslint-disable-next-line react/no-access-state-in-setstate
            [type]: newState,
          });
        }
        this.endLoading(type);
      }),
      ...this.compromiseApiRequests.map(async (type) => {
        const { post: p2, category } = this.state;
        const newState = await callCompromiseApi(p2, category, postBody, type);
        if (newState &amp;&amp; newState.length > 0) {
          this.setState({
            // eslint-disable-next-line react/no-access-state-in-setstate
            [type]: newState,
          });
        }
        this.endLoading(type);
      }),
    ]);
    this.makeClickable('#post-text p, #post-text li');
    this.registerDefinitionsOnWordClick('#post-text p .word, #post-text li .word');
    this.fixImgSrc();
    await p;
  }

  /**
   * @param {string} selector
   */
  makeClickable(selector) {
    const nodes = document.querySelectorAll(selector);
    for (const n of nodes) {
      for (const child of n.childNodes) {
        if (child.nodeName === '#text') {
          const matches = findAllMatches(child.nodeValue, /([a-z]{2,})/gi);
          for (const w of new Set(matches)) {
            if (!this.bannedWords.has(w)) {
              const regExp = new RegExp(`\\b${w}\\b`, 'gi');
              const replaceValue = `&lt;button class="word">${w}&lt;/button>`;
              n.innerHTML = n.innerHTML.replace(regExp, replaceValue);
            }
          }
        }
      }
    }
  }

  /**
   * @param {string} selector
   */
  registerDefinitionsOnWordClick(selector) {
    for (const node of document.querySelectorAll(selector)) {
      node.addEventListener('click', async () => {
        const word = node.innerText;
        try {
          const definition = await define(word);
          if (definition) {
            this.setState({ word, definition });
            this.makeClickable('.toast > .toast-body');
            this.registerDefinitionsOnWordClick('.toast > .toast-body .word');
          }
        } catch (e) {
          console.error(e);
        } finally {
          this.endLoading('word');
        }
      });
    }
  }

  fixImgSrc() {
    const { state: { category } } = this;
    for (const img of document.querySelectorAll('img[src]')) {
      const src = img.getAttribute('src');
      if (src &amp;&amp; !src.startsWith('http')) {
        const value = join(process.env.REACT_APP_ASSETS_ROOT, category.substr(1), src);
        img.setAttribute('src', value);
      }
    }
  }

  /**
   * @param {string} what
   */
  beginLoading(what) {
    this.setState(({ _loading }) => ({ _loading: [..._loading, what] }));
  }

  /**
   * @param {string} what
   */
  endLoading(what) {
    this.setState(({ _loading }) => {
      for (let i = 0; i &lt; _loading.length; i += 1) {
        if (_loading[i] === what) {
          return {
            _loading: _loading.slice(0, i).concat(_loading.slice(i + 1)),
          };
        }
      }
      return {};
    });
  }

  /**
   * @param {string} item
   * @returns {boolean}
   */
  didLoad(...item) {
    const { _loading } = this.state;
    return item.reduce((prev, focus) => prev &amp;&amp; _loading.indexOf(focus) &lt; 0, true);
  }

  /**
   * @param {string} newCategory
   * @param {boolean} [saveHistory]
   */
  absCategory(newCategory, saveHistory = true) {
    const { state: { category, post } } = this;
    if (category !== newCategory) {
      if (newCategory === '') {
        this.absCategory('/');
      } else if (newCategory.length > 1 &amp;&amp; newCategory.endsWith('/')) {
        this.absCategory(newCategory.replace(/\/$/, ''));
      } else {
        const title = `Blog - category "${basename(newCategory)}"`;
        if (saveHistory) {
          window.history.pushState({ category: newCategory, post }, title, newCategory);
        }
        this.setState({ category: newCategory });
      }
    }
  }

  /**
   * @param {boolean} [slice]
   * @returns {string}
   */
  static getPostBody(slice = true) {
    const s = [...document.getElementById('post-text').querySelectorAll('p')].map((p) => p.innerText).join('\n');
    return slice ? s.slice(0, 10000) : s;
  }

  clearDefinition() {
    this.setState({ word: null, definition: null });
  }

  /**
   * @returns {*}
   */
  render() {
    const {
      absCategory,
      absPost,
      author,
      categories,
      clearDefinition,
      compromiseApiRequests,
      didLoad,
      naturalApiRequests,
      parentCategories,
      parentCategory,
      parentPosts,
      posts,
      state,
    } = this;
    const {
      definition, category, post, word, postText, data: { trees },
    } = state;
    return (
      &lt;div hidden={isObjectEmpty(trees)}>
        &lt;WordDefinition
          word={word}
          definition={definition}
          clearDefinition={clearDefinition}
        />
        &lt;main
          className="container-fluid mt-0 mt-xl-5 mt-lg-5 mt-md-0 mt-sm-0 d-flex no-gutters flex-column flex-xl-row flex-lg-row flex-md-row flex-sm-column"
          style={{ minHeight: '84vh' }}
        >
          &lt;section
            className="col-xl-2 col-lg-2 d-xl-block d-lg-block d-md-none d-sm-none d-none"
          >
            &lt;Title
              parentCategory={parentCategory}
              parentCategories={parentCategories}
            />
            &lt;ParentCategories
              absCategory={absCategory}
              category={category}
              parentCategories={parentCategories}
              parentCategory={parentCategory}
            />
            &lt;ParentPosts
              parentCategory={parentCategory}
              parentPosts={parentPosts}
              parentCategories={parentCategories}
              post={post}
              absPost={absPost}
            />
          &lt;/section>
          &lt;section
            className="col-xl-2 col-lg-2 col-md-3 col-sm-12 my-4 my-xl-0 my-lg-0 my-md-4 my-sm-4"
          >
            &lt;div className="text-center col mx-auto">
              &lt;TitleMiddle
                parentCategory={parentCategory}
                category={category}
                absCategory={absCategory}
              />
            &lt;/div>
            &lt;Categories
              absCategory={absCategory}
              category={category}
              categories={categories}
            />
            &lt;Posts
              categories={categories}
              category={category}
              absPost={absPost}
              post={post}
              posts={posts}
            />
          &lt;/section>
          &lt;section
            hidden={!postText}
            className="col-xl-8 col-lg-8 col-md-9 col-sm-12 container-fluid row justify-content-around"
          >
            &lt;div className="col-xl-1 col-lg-1 d-xl-block d-lg-block d-md-none d-sm-none d-none" />
            &lt;section className="col-xl-8 col-lg-8 col-md-12 col-sm-12">
              &lt;div
                id="post-text"
                dangerouslySetInnerHTML={{ __html: postText }}
                className="my-4 my-xl-0 my-lg-0 my-md-4 my-sm-4"
              />
            &lt;/section>
            &lt;div className="col-xl-1 col-lg-1 d-xl-block d-lg-block d-md-none d-sm-none d-none" />
            &lt;section className="col-xl-1 col-lg-1 d-xl-block d-lg-block d-md-none d-sm-none d-none">
              &lt;NLPInfo
                postText={postText}
                compromiseApiRequests={compromiseApiRequests}
                naturalApiRequests={naturalApiRequests}
                state={state}
              />
            &lt;/section>
            &lt;div className="col-xl-1 col-lg-1 d-xl-block d-lg-block d-md-none d-sm-none" />
          &lt;/section>
          &lt;div
            hidden={postText || didLoad.call(this, 'postText')}
            className="mx-auto my-auto"
          >
            &lt;Spinner style={{ width: '3rem', height: '3rem' }} />
          &lt;/div>
        &lt;/main>
        &lt;Footer author={author} />
      &lt;/div>
    );
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#absCategory">absCategory</a></li><li><a href="global.html#absPost">absPost</a></li><li><a href="global.html#beginLoading">beginLoading</a></li><li><a href="global.html#callCompromiseApi">callCompromiseApi</a></li><li><a href="global.html#callNaturalApi">callNaturalApi</a></li><li><a href="global.html#categories">categories</a></li><li><a href="global.html#checkValidServiceWorker">checkValidServiceWorker</a></li><li><a href="global.html#componentDidMount">componentDidMount</a></li><li><a href="global.html#countSent">countSent</a></li><li><a href="global.html#countWords">countWords</a></li><li><a href="global.html#define">define</a></li><li><a href="global.html#didLoad">didLoad</a></li><li><a href="global.html#endLoading">endLoading</a></li><li><a href="global.html#findAllMatches">findAllMatches</a></li><li><a href="global.html#fmtHeading">fmtHeading</a></li><li><a href="global.html#getBlogData">getBlogData</a></li><li><a href="global.html#getPostBody">getPostBody</a></li><li><a href="global.html#getPostHTML">getPostHTML</a></li><li><a href="global.html#getTimeToReadInMin">getTimeToReadInMin</a></li><li><a href="global.html#initPostText">initPostText</a></li><li><a href="global.html#isDotFile">isDotFile</a></li><li><a href="global.html#isFile">isFile</a></li><li><a href="global.html#isObjectEmpty">isObjectEmpty</a></li><li><a href="global.html#makeClickable">makeClickable</a></li><li><a href="global.html#parentCategories">parentCategories</a></li><li><a href="global.html#parentCategory">parentCategory</a></li><li><a href="global.html#parentPosts">parentPosts</a></li><li><a href="global.html#posts">posts</a></li><li><a href="global.html#register">register</a></li><li><a href="global.html#registerDefinitionsOnWordClick">registerDefinitionsOnWordClick</a></li><li><a href="global.html#registerValidSW">registerValidSW</a></li><li><a href="global.html#render">render</a></li><li><a href="global.html#unique">unique</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Wed Jan 01 2020 12:23:49 GMT+0000 (Greenwich Mean Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
